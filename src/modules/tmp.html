<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/calendar.css">
  <link rel="stylesheet" href="../css/reset.css">
  <title>Document</title>
</head>

<body>
  <div class="hour__container" style='width: 700px; color: red'>
    <div class="hour__btn-left button__left button-array"></div>
    <div class="list__hour-container">
      <ul class="list__hour">
        <li class="hour">0</li>
        <li class="hour">0.5</li>
        <li class="hour">1</li>
        <li class="hour">1.5</li>
        <li class="hour">2</li>
        <li class="hour">2.5</li>
        <li class="hour">3</li>
        <li class="hour">3.5</li>
        <li class="hour">4</li>
        <li class="hour">4.5</li>
        <li class="hour">5</li>
        <li class="hour">6</li>
        <li class="hour">7</li>
        <li class="hour">8</li>
        <li class="hour">8.5</li>
        <li class="hour">9</li>
        <li class="hour">9.5</li>
        <li class="hour">10</li>
      </ul>
    </div>
    <div class="hour__btn-right button__right button-array"></div>
  </div>
  <script>
     function debounce(func, wait) {
    let timeout;
    return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
    };
}

class moveListHoursOnTouch {
    #listHour = document.querySelector('.list__hour');
    #listHourContainer = document.querySelector('.list__hour-container');
    #shiftX = null;
    #initTouch = 0;
    #rightEdge = this.#listHour.offsetWidth - this.#listHourContainer.offsetWidth ;

    constructor() {
        // Lega i metodi solo una volta nel costruttore
        // this.moveListHours = this.moveListHours.bind(this);
        this.onListDown = this.onListDown.bind(this);
        this.onListUp = this.onListUp.bind(this);
        this.onThumbMove = this.onThumbMove.bind(this);

        // Applica il debouncing al metodo onThumbMove con un ritardo di 10ms (o qualunque tempo desiderato)
        this.debouncedOnThumbMove = debounce(this.onThumbMove, 100);

        this.#listHour.addEventListener('pointerdown', this.onListDown);
    }

    onListDown(e) {
        e.preventDefault(); // Impedisce la selezione del testo (azione del browser)
        console.log('onListDown');
        this.#initTouch = e.clientX;
        this.#shiftX = e.clientX - this.#listHour.getBoundingClientRect().left;
        this.#listHour.setPointerCapture(event.pointerId);

        // Aggiungi l'evento pointermove con debouncing
        this.#listHour.addEventListener('pointermove', this.onThumbMove);

        // Aggiungi l'evento pointerup
        this.#listHour.addEventListener('pointerup', this.onListUp);
    }

    onListUp(e) {
        // Rimuovi gli eventi pointermove e pointerup quando il trascinamento Ã¨ terminato
        this.#listHour.removeEventListener('pointermove', this.onThumbMove);
        this.#listHour.removeEventListener('pointerup', this.onListUp);

        console.log('Trascinamento terminato');
    }

    onThumbMove(e) {
      let newLeft = e.clientX - this.#shiftX - this.#listHourContainer.getBoundingClientRect().left;
      // if the pointer is out of slider => adjust left to be within the boundaries
      if (newLeft > 0) {
        newLeft = 0;
      }
      console.log(this.#rightEdge);
      
      if (Math.abs(newLeft) > this.#rightEdge) {
        newLeft = -this.#rightEdge;
}

this.#listHour.style.left = newLeft + 'px';

        // console.log(maxLeft, 'maxLeft', newLeft, 'NL');
    }
}

    

new moveListHoursOnTouch()
  </script>
</body>

</html>